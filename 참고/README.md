# 숫자 게임 (Number Game) 📊 - 초보자를 위한 상세 분석

Python과 그래픽 라이브러리인 Tkinter를 사용하여 만든 교육용 수학 게임입니다. 학생들이 주어진 목표 숫자를 만들기 위해 `1`, `+`, `*`, `(`, `)` 기호만으로 수학 표현식을 구성하는 게임입니다. 1라운드 개인전과 2라운드 팀전 모드를 지원하며, 코스트(비용) 개념을 도입하여 전략적 사고를 유도합니다.113212123231
123
---

## 📖 이 문서를 읽기 전에

이 문서는 프로그래밍을 처음 접하는 학생이나 초보 개발자도 이 프로젝트를 통해 학습할 수 있도록 **매우 상세하게** 작성되었습니다. 각 파일의 역할뿐만 아니라 코드 한 줄 한 줄의 의미까지 최대한 쉽게 풀어 설명하려고 노력했습니다.111112

---

## 🎯 프로그램의 목표와 교육적 가치

### 🌟 주요 기능
- **1라운드 개인전 모드**: 각 학생이 제한된 비용(코스트) 내에서 목표 숫자를 만드는 개인전입니다.
- **2라운드 팀전 모드**: 4명의 학생이 한 팀이 되어 순서대로 식을 완성해나가며 목표 숫자를 만드는 협동전입니다.
- **관리자 설정**: 선생님이 문제, 기호별 비용, 게임 시간 등 모든 규칙을 직접 설정할 수 있습니다.
- **네트워크 대전**: 같은 네트워크에 있는 친구들과 실시간으로 게임을 즐길 수 있습니다.
- **쉬운 배포**: `build.bat` 파일 실행 한 번으로 어디서든 실행 가능한 파일(`*.exe`)을 만들 수 있습니다.

### 🎓 교육적 가치
1. **수학적 사고력 향상**:
   - **연산자 우선순위**: 괄호와 곱셈, 덧셈의 우선순위를 자연스럽게 체득합니다.
   - **전략적 문제 해결**: 최소한의 비용으로 목표를 달성하기 위해 다양한 해결책을 고민하게 됩니다.
2. **프로그래밍 학습**:
   - **GUI 프로그래밍**: Tkinter를 이용해 어떻게 그래픽 사용자 인터페이스(GUI)를 만드는지 배울 수 있습니다.
   - **네트워크 프로그래밍**: `socket`을 이용한 실시간 통신 원리를 이해할 수 있습니다.
   - **객체 지향 프로그래밍(OOP)**: 역할에 따라 클래스를 나누고, 재사용 가능한 코드를 작성하는 방법을 배웁니다.
   - **파일 입출력**: 게임 설정을 파일(`*.json`)로 저장하고 불러오는 방법을 학습합니다.

---

## 📁 프로젝트 구조: 우리 프로그램의 지도

프로그램은 여러 폴더와 파일로 구성되어 있습니다. 각 파일은 특정 역할을 맡고 있어, 체계적으로 관리됩니다.

```
영캠2/
├── 📜 main.py                # ✅ 프로그램의 시작점
├── 🎨 constants.py           # ✅ 색상, 폰트 등 디자인 설정
├── 📦 requirements.txt       # ✅ 필요한 추가 라이브러리 목록
├── 🚀 build.bat              # ✅ 프로그램을 실행 파일로 만드는 스크립트
├── ⚙️ NumberGame.spec        # ✅ build.bat이 사용하는 상세 설정
│
├── 🧠 game_logic/            # 룰과 계산을 담당하는 폴더
│   └── 🧮 calculator.py     # 룰에 따라 수식을 계산하는 파일
│
├── 🌐 network/               # 네트워크 통신(멀티플레이) 담당 폴더
│   ├── 🖥️ server.py         # 게임 서버 역할
│   ├── 🕹️ client.py         # 게임 클라이언트(참가자) 역할
│   └── 📡 discovery.py       # 네트워크에서 서버를 자동으로 찾는 역할
│
├── 🖼️ ui/                   # 사용자에게 보여지는 화면(UI) 담당 폴더
│   ├── 🏠 main_menu_view.py       # 첫 메인 메뉴 화면
│   ├── 👆 mode_selection_view.py  # 게임 모드 선택 화면
│   ├── 👤 single_player_view.py   # 1인용 게임 화면
│   ├── 👥 multiplayer_view.py     # 2인용 네트워크 게임 화면
│   ├── 👨‍👩‍👧‍👦 team_game_view.py       # 팀전 게임 화면
│   ├── 💵 team_cost_distribution_view.py # 팀 코스트 분배 화면
│   ├── 🧩 student_panel.py        # 학생 입력창(재사용되는 부품)
│   └── 🔑 admin_problem_editor.py # 관리자 설정 화면
│
└── 🛠️ utils/                  # 기타 유용한 도구들을 모아둔 폴더
    └── 💾 problem_store.py    # 게임 설정을 파일로 저장하고 불러오는 역할
```

---

## 🔧 파일별 상세 설명: 코드 해부하기

### 📌 1. 핵심 파일들

#### `main.py`: 우리 프로그램의 심장
이 파일은 프로그램을 실행하면 가장 먼저 호출되는 파일입니다. 전체 창을 만들고, 여러 화면(View)들을 교체해주는 역할을 합니다.

```python
# main.py

# 필요한 라이브러리와 다른 파일들을 가져옵니다.
import tkinter as tk  # GUI를 만들기 위한 라이브러리
from constants import *  # 우리가 정의한 색상, 폰트
from ui.main_menu_view import MainMenuView # 첫 화면

# App 클래스는 프로그램의 전체 창(Window)을 의미합니다.
class App(tk.Tk):
    def __init__(self):
        super().__init__() # tk.Tk의 기능을 상속받습니다.
        self.title("숫자 게임") # 창 제목 설정
        self.geometry("800x600") # 창 크기 설정
        self.configure(bg=BG_COLOR) # 배경색 설정

        self._frame = None # 현재 보여지는 화면을 저장할 변수
        self.switch_frame(MainMenuView) # 첫 화면으로 MainMenuView를 보여줍니다.

    # 화면을 전환하는 중요한 함수입니다.
    def switch_frame(self, frame_class, *args, **kwargs):
        """기존 화면을 없애고 새로운 화면으로 교체합니다."""
        if self._frame is not None:
            self._frame.destroy() # 이전 화면이 있으면 삭제
        # 새 화면을 생성하고 창에 채워 넣습니다.
        self._frame = frame_class(self, *args, **kwargs)
        self._frame.pack(fill="both", expand=True)

# 이 파일이 직접 실행될 때만 아래 코드를 실행합니다.
if __name__ == "__main__":
    app = App() # App 객체를 생성
    app.mainloop() # 창이 꺼지지 않고 계속 실행되도록 합니다.
```

#### `constants.py`: 디자인 가이드북
이 파일은 프로그램 전체의 디자인 통일성을 위해 색상과 폰트 정보를 한곳에 모아둔 파일입니다. 만약 버튼 색상을 바꾸고 싶다면, 이 파일만 수정하면 됩니다.

```python
# constants.py

# --- 색상 (다크 모드 테마) ---
BG_COLOR = "#1e1e2e"          # 전체 배경색
COMPONENT_BG_COLOR = "#2a2a3e" # 버튼 등 구성요소 배경색
INPUT_BG_COLOR = "#3a3a4e"   # 입력창 배경색
TEXT_COLOR = "#f8f8f2"         # 글자색
ACCENT_COLOR = "#7c3aed"      # 강조색 (보라색 계열)
SUCCESS_COLOR = "#10b981"     # 성공 표시색 (초록색 계열)
ERROR_COLOR = "#ef4444"       # 에러 표시색 (빨간색 계열)

# --- 폰트 (글꼴과 크기) ---
TITLE_FONT = ("Segoe UI", 24, "bold") # 제목 폰트
SUBTITLE_FONT = ("Segoe UI", 18)      # 부제목 폰트
BODY_FONT = ("Segoe UI", 12)        # 일반 텍스트 폰트
INPUT_FONT = ("Segoe UI", 32)       # 큰 입력창 폰트
TIMER_FONT = ("Segoe UI", 46, "bold") # 타이머 전용 큰 폰트
```
**✨ 설계 의도**: 이렇게 상수를 한 곳에 모아두면, 나중에 디자인을 변경할 때 여러 파일을 헤맬 필요 없이 이 파일 하나만 수정하면 되므로 유지보수가 매우 편리해집니다.

---

### 🧠 2. `game_logic` 폴더: 게임의 두뇌

#### `calculator.py`: 수학 천재
이 파일은 게임의 핵심 규칙을 담당합니다. 학생이 입력한 수식이 올바른지 검사하고, 결과를 계산하며, 사용된 비용(코스트)을 분석합니다.

- **`preprocess_expression(expr, mode)`**: 수식을 계산하기 전에 정리하고, 규칙에 어긋나는지 확인합니다. 예를 들어, `1++1` 같은 잘못된 입력이나 허용되지 않은 기호(`2`, `-` 등)를 찾아냅니다.
- **`calculate_expression(expr, mode)`**: 정리된 수식을 `eval()` 함수를 이용해 계산합니다. `eval()`은 문자열을 실제 코드로 실행하는 강력한 함수지만, 보안에 취약할 수 있어 안전장치와 함께 사용됩니다.
- **`analyze_input(text, mode)`**: 학생이 입력한 전체 텍스트를 분석하여, 각 줄의 계산 결과와 총 사용 비용을 반환합니다.

**💡 핵심 코드 들여다보기 - 코스트 계산**:
```python
# game_logic/calculator.py

# 'cost' 모드일 때, 기호별로 설정된 비용을 계산합니다.
# 특히 '1'은 연속된 개수에 따라 비용이 책정됩니다. (예: '111'은 1코스트 * 3)
def analyze_input(text, mode='normal'):
    # ... (생략) ...
    cost_map = load_costs() # utils/problem_store.py에서 비용 설정 불러오기

    for line in expressions:
        # ... (생략) ...
        if mode == 'cost':
            # 한 줄의 모든 문자를 확인하며 비용 계산
            i = 0
            while i < len(stripped_line):
                if stripped_line[i] == '1':
                    ones_count = 0 # 연속된 '1'의 개수
                    j = i
                    while j < len(stripped_line) and stripped_line[j] == '1':
                        ones_count += 1
                        j += 1
                    # '1'의 비용 * 연속된 개수 만큼 총 비용에 더함
                    total_cost += ones_count * cost_map.get('1', 1)
                    i = j # 다음 문자로 이동
                elif stripped_line[i] in cost_map:
                    # '+'나 '*' 같은 다른 기호의 비용을 더함
                    total_cost += cost_map[stripped_line[i]]
                    i += 1
                else:
                    i += 1
    # ... (생략) ...
```

---

### 💾 3. `utils` 폴더: 만능 도구 상자

#### `problem_store.py`: 게임의 기억 장치
이 파일은 관리자가 설정한 모든 데이터(문제, 비용, 시간 등)를 컴퓨터에 파일로 저장하고, 필요할 때 다시 불러오는 역할을 합니다. 덕분에 프로그램을 껐다 켜도 설정이 유지됩니다.

- **저장 형식**: 모든 데이터는 사람이 읽기 쉬운 `JSON` 형식으로 저장됩니다.
- **파일 위치**: `game_settings` 라는 폴더 안에 각 설정별로 파일이 생성됩니다.
- **`load_...()` 함수들**: `custom_problems.json` 같은 파일에서 데이터를 읽어옵니다.
- **`save_...()` 함수들**: 관리자 화면에서 설정한 내용을 해당 파일에 저장합니다.

**💡 핵심 코드 들여다보기 - PyInstaller 호환성**:
프로그램을 `.exe` 파일로 만들면 파일 경로를 찾는 방식이 달라집니다. 아래 코드는 개발 환경과 배포 환경 모두에서 올바르게 `game_settings` 폴더를 찾도록 해주는 중요한 부분입니다.
```python
# utils/problem_store.py
import sys
from pathlib import Path

# getattr(sys, 'frozen', False)는 .exe로 실행되었는지 확인하는 코드입니다.
if getattr(sys, 'frozen', False):
    # .exe 파일일 경우, 실행 파일이 있는 폴더를 기준으로 삼습니다.
    BASE_DIR = Path(sys.executable).parent
else:
    # 개발 환경(python main.py 실행)일 경우, 이 파일의 위치를 기준으로 합니다.
    BASE_DIR = Path(__file__).resolve().parent.parent

# 설정 파일을 저장할 디렉토리를 지정하고, 없으면 생성합니다.
SETTINGS_DIR = BASE_DIR / "game_settings"
SETTINGS_DIR.mkdir(exist_ok=True)
```

---

### 🌐 4. `network` 폴더: 세상과의 연결

#### `server.py` & `client.py`: 멀티플레이의 주역
이 두 파일은 네트워크 대전 기능을 담당합니다. 한 명은 `서버`(방장)가 되어 게임을 열고, 다른 한 명은 `클라이언트`(참가자)가 되어 접속합니다.

- **`GameServer` (`server.py`)**:
  - 게임 서버를 열고 클라이언트의 접속을 기다립니다.
  - 4자리 **접속 코드**를 무작위로 생성하여, 아는 사람만 들어오게 합니다.
  - 클라이언트로부터 받은 메시지를 다른 클라이언트에게 전달(브로드캐스트)합니다.
- **`GameClient` (`client.py`)**:
  - 서버의 IP 주소와 접속 코드를 이용해 서버에 연결을 시도합니다.
  - 연결에 성공하면, 서버로부터 메시지를 받거나 서버로 메시지를 보낼 수 있습니다.

#### `discovery.py`: 길 잃은 친구를 위한 등대
복잡한 IP 주소를 직접 입력하는 것은 불편합니다. 이 파일은 **Zeroconf**라는 기술을 사용해 같은 네트워크에 있는 게임 서버를 자동으로 찾아 목록으로 보여줍니다.

- **`ZeroconfService`**: 서버가 "나 여기 있어!"라고 네트워크에 자신의 존재를 알리는 역할.
- **`ZeroconfBrowser`**: 클라이언트가 네트워크를 둘러보며 "누구 게임 열린 사람 있어?"라고 외치고, 응답을 듣는 역할.

---

### 🖼️ 5. `ui` 폴더: 사용자의 눈과 손

이 폴더에는 사용자가 직접 보고 상호작용하는 모든 화면(View)들이 들어있습니다. 각 `..._view.py` 파일은 하나의 화면을 담당합니다.

#### `main_menu_view.py`: 첫인상
- "숫자 게임 시작", "관리자 메뉴" 버튼이 있는 메인 화면입니다.
- "관리자 메뉴"는 비밀번호(`891109!!`)를 맞춰야 들어갈 수 있습니다.

#### `mode_selection_view.py`: 갈림길
- "1라운드 개인전", "2라운드 팀전" 등 게임 모드를 선택하는 화면입니다.
- 모드를 선택해야 "시작" 버튼이 활성화됩니다.

#### `single_player_view.py`: 나 홀로 싸움
- 학생 두 명이 한 컴퓨터에서 차례로 문제를 푸는 1라운드 개인전 화면입니다.
- 두 개의 `StudentPanel`(학생 패널)을 위아래로 배치한 구조입니다.
- 타이머가 있어 제한 시간 내에 풀어야 합니다.

#### `team_cost_distribution_view.py`: 전략 회의
- 2라운드 팀전을 시작하기 전에, 팀 전체의 총 비용을 4명의 학생에게 나눠주는 화면입니다.
- 총합이 맞지 않으면 게임을 시작할 수 없습니다.

#### `team_game_view.py`: 우리 팀의 협동 작전
- 이 프로그램에서 가장 복잡하고 중요한 화면입니다. 4명의 학생이 협력하여 하나의 수식을 완성합니다.

**💡 핵심 기능**:
1. **순차적 입력**: 현재 차례인 학생만 입력창이 활성화됩니다.
2. **누적 결과**: 이전 학생이 입력한 내용에 이어서 자신의 수식을 추가합니다.
3. **실시간 피드백**: 입력할 때마다 남은 비용과 현재까지의 계산 결과가 계속 업데이트됩니다.
4. ** 타임**: "전체 초기화" 버튼을 누르면, 모든 내용이 사라지고 정해진 시간 동안 팀원들과 전략을 짤 수 있는 '작전회의' 시간이 주어집니다.
5. **성공 기록**: 제한 시간 내에 목표 숫자를 만든 성공 기록들이 오른쪽에 표시됩니다.

#### `student_panel.py`: 재사용 가능한 부품
- 1라운드 개인전에서 각 학생의 입력 공간은 매우 유사합니다. 이처럼 반복되는 UI 요소를 하나의 클래스로 만들어 **재사용**합니다. 이것이 바로 `StudentPanel`입니다.
- **상태 시각화**: 자기 차례일 때(활성)는 패널이 밝은 녹색으로, 아닐 때(비활성)는 어두운 색으로 표시되어 시각적으로 현재 상태를 쉽게 알 수 있습니다.

#### `admin_problem_editor.py`: 게임의 설계자
- 선생님(관리자)이 게임의 모든 규칙을 수정하는 화면입니다.
- 문제 목록, 기호별 비용, 라운드별 시간, 작전 타임 등 아주 세세한 부분까지 모두 제어할 수 있습니다.
- "저장" 버튼을 누르면 `utils/problem_store.py`를 통해 모든 변경사항이 파일에 기록됩니다.

---

### 🔨 6. 빌드와 배포

#### `requirements.txt`: 쇼핑 리스트
이 프로그램이 실행되려면 `zeroconf`와 `pyinstaller`라는 추가 라이브러리가 필요합니다. 이 파일은 필요한 라이브러리 목록을 적어둔 것입니다.

#### `build.bat` & `NumberGame.spec`: 자동 포장 기계
- **`build.bat`**: 이 파일을 더블 클릭하면, `requirements.txt`에 적힌 라이브러리를 자동으로 설치하고, `PyInstaller`를 이용해 모든 파이썬 코드를 하나의 실행 파일(`.exe`)로 압축해줍니다.
- **`NumberGame.spec`**: `PyInstaller`가 어떤 파일들을 어떻게 압축할지 상세하게 적어둔 설정 파일입니다. `build.bat`은 이 명세서를 보고 작업을 수행합니다.

**💡 핵심 코드 들여다보기 - `NumberGame.spec`**:
```python
# NumberGame.spec

# ... (생략) ...
# 'datas'는 코드 파일 외에 추가로 포함할 파일들 목록입니다.
# 우리 프로젝트의 모든 .py 파일과 설정 파일들을 포함시킵니다.
a = Analysis(
    ['main.py'],
    # ... (생략) ...
    datas=[('*.py', '.'), ('ui/*.py', 'ui'), ('game_logic/*.py', 'game_logic'), ('network/*.py', 'network'), ('utils/*.py', 'utils')],
    # ... (생략) ...
)
# ... (생략) ...
exe = EXE(
    # ... (생략) ...
    name='NumberGame', # 생성될 파일 이름
    console=False,     # True로 하면 실행 시 검은색 콘솔 창이 함께 뜹니다. GUI 프로그램이므로 False로 설정합니다.
    icon='NONE',       # 아이콘 파일이 있다면 경로를 지정할 수 있습니다.
)
```

---

## 🚀 직접 해보기

### 1. 개발 환경에서 실행하기 (코드 수정 가능)
1. 이 프로젝트 폴더를 엽니다.
2. 터미널(명령 프롬프트 또는 PowerShell)을 엽니다.
3. 아래 명령어를 차례로 입력합니다.
   ```bash
   # 필요한 라이브러리 설치
   pip install -r requirements.txt

   # 프로그램 실행
   python main.py
   ```

### 2. 실행 파일(exe) 만들기 - 상세 가이드

이 프로젝트는 **PyInstaller**를 사용하여 Python 코드를 Windows에서 실행 가능한 exe 파일로 변환합니다.

#### 🔧 빌드 시스템 구성

**1. PyInstaller 사용**
- Python 코드를 실행 가능한 exe 파일로 변환하는 도구
- `requirements.txt`에 `pyinstaller`가 포함되어 있음

**2. 빌드 과정 (`build.bat` 실행 시)**
```batch
# 1단계: 의존성 설치
pip install -r requirements.txt
  - zeroconf (네트워크 발견용)
  - pyinstaller (exe 빌드용)

# 2단계: PyInstaller 실행
python -m PyInstaller NumberGame.spec --noconfirm --clean
  - --noconfirm: 기존 빌드 덮어쓰기 확인 없이 진행
  - --clean: 이전 빌드 파일들 정리
```

**3. 설정 파일 (`NumberGame.spec`)**
- **진입점**: `main.py`
- **포함 파일들**:
  - `*.py` (루트 디렉토리 Python 파일들)
  - `ui/*.py` (UI 모듈)
  - `game_logic/*.py` (게임 로직)
  - `network/*.py` (네트워크 모듈)
  - `utils/*.py` (유틸리티 모듈)
- **실행 방식**: `console=False` (콘솔창 없는 윈도우 앱)
- **압축**: `upx=True` (파일 크기 최적화)

#### 📋 실행 방법
1. 프로젝트 폴더에 있는 `build.bat` 파일을 더블 클릭합니다.
2. 잠시 기다리면 `dist`라는 폴더가 생성됩니다.
3. `dist/NumberGame` 폴더 안에 있는 `NumberGame.exe` 파일을 실행하면 됩니다.

#### ✨ 특징
- **단일 실행 파일**: 모든 의존성이 포함된 하나의 exe
- **설정 파일 지원**: `game_settings/` 폴더에 JSON 설정 파일들 자동 저장
- **윈도우 앱**: 콘솔창 없이 GUI로만 실행
- **배포 용이**: Python 설치 없이도 다른 컴퓨터에서 실행 가능

### 3. 네트워크 대전 사용법

#### 🌐 호스트(방 만들기)
1. 메인 메뉴에서 **"네트워크 대전"** → **"방 만들기 (호스트)"** 버튼을 누릅니다.
2. 원하는 게임 모드(예: 1라운드 팀별 개인전)를 선택하고 시작을 누르면 서버가 열립니다.
3. 화면 상단에 표시되는 **참가 코드**를 친구에게 알려주세요.
4. 같은 네트워크에 있는 친구가 참가하면 자동으로 목표 숫자가 주어지고 게임이 시작됩니다.

#### 💻 게스트(방 참가)
1. 메인 메뉴에서 **"네트워크 대전"** → **"방 참가하기 (게스트)"**를 선택합니다.
2. 자동으로 같은 네트워크의 열린 방 목록을 탐색합니다.
   - 목록에서 방을 더블 클릭하면 참가 코드 입력 창이 나타납니다.
   - 만약 목록에 보이지 않으면 **수동으로 IP/포트 입력** 버튼으로 직접 입력할 수 있습니다.
3. 호스트가 알려준 4자리 참가 코드를 입력하면 연결되고, 호스트가 시작할 때까지 대기합니다.

#### ✏️ 관리자 메뉴에서 네트워크 문제 관리
- 관리자 설정 창에 **"네트워크 대전 문제 설정"** 섹션이 추가되었습니다.
- 1라운드(모드 I/II)와 2라운드 팀전용 문제를 각각 입력할 수 있으며, 비워두면 기존 오프라인 문제 목록을 그대로 사용합니다.
- 설정은 `game_settings/network_mode1_problems.json`, `network_mode2_problems.json`, `network_team_problems.json`에 저장됩니다.

#### 🔁 여러 판 연속 진행 & 스코어 보드
- 한 라운드가 끝나면 호스트가 자동으로 다음 문제를 열어 **1:0, 2:0, 3:1**과 같은 스코어가 상단에 누적 표시됩니다.
- 1라운드 코스트 모드에서는 `game_settings/mode1_problems.json`에 등록된 문제 순서를 우선 사용하고, 모두 소진하면 무작위 목표 숫자가 이어집니다.
- 각 라운드 기록은 화면 하단 리스트로 남아서 언제든 직전 문제/승자를 확인할 수 있습니다.
- **3분 카운트다운**: 네트워크 1라운드는 3분 동안 플레이하며, 목표 숫자를 맞힌 뒤 문제에 설정된 최적 코스트에 얼마나 근접했는지로 승자를 가립니다. 둘 다 정답을 못 찾으면 목표값과의 차이가 더 적은 참가자가 승리하고, 완전히 동일하면 무승부입니다.
- **히스토리 공유**: 내 제출과 상대 제출이 하나의 텍스트 패널에 시간 순서대로 누적되어 즉시 비교·피드백이 가능합니다.
- **관전 모드**: 플레이어 두 대 외의 PC는 네트워크 대전 화면의 관전 버튼을 눌러 동일한 참가 코드로 접속할 수 있으며, 스코어·타이머·히스토리를 읽기 전용으로 확인할 수 있습니다.

#### 🔥 2라운드 네트워크 팀전 (4 vs 4)
1. **호스트/게스트 모두** 네트워크 대전 → 팀전을 선택하면, 기존과 동일한 COIN 분배 화면이 열립니다. (네트워크용 문제 목록이 자동으로 적용됩니다.)
2. 분배를 마치고 "시작"을 누르면 각각 **NetworkTeamGameView**가 실행되어 같은 목표 숫자를 향해 4명이 순차적으로 식을 완성합니다.
3. 팀전 역시 3분 카운트다운이 적용되며, 시간 종료 후 **최적해 여부 → 사용 COIN → 제출 시간** 순으로 승패가 결정됩니다.
4. 화면 상단에 우리 팀과 상대 팀의 최고 기록, 전체 히스토리가 표시되어 작전회의나 피드백 자료로 활용할 수 있습니다.
5. 게스트는 정답을 제출해도 즉시 승부가 나지 않으며, 호스트가 시간 종료 후 집계한 결과를 받아 확인합니다.
6. 관전자는 팀전에서도 동일한 기록판을 볼 수 있어 대회를 여러 PC에서 동시에 중계할 수 있습니다.
7. 팀전 문제는 `game_settings/network_team_problems.json`(또는 일반 `team_problems.json`)에서 관리됩니다.

---

## 🔧 주요 기술적 문제 해결 기록

### 팀전 모드 텍스트 색상 표시 문제 해결

#### 🚨 문제 상황
팀전 모드에서 학생들이 순서대로 텍스트를 편집할 때, 색상 표시에 심각한 문제가 있었습니다:

1. **기본 문제**: 이전 학생이 입력한 내용은 노란색, 현재 학생이 입력하는 내용은 초록색으로 표시되어야 함
2. **끼워넣기 문제**: 텍스트 중간에 문자를 삽입할 때 색상이 잘못 적용됨
3. **동일 문자 삽입 문제**: 같은 문자가 연속으로 있을 때 중간에 같은 문자를 삽입하면 가장 오른쪽 문자가 초록색으로 변함

**예시:**
- 이전 학생: '1111' 입력 (노란색)
- 현재 학생: 두 번째와 세 번째 '1' 사이에 '1' 삽입
- 예상 결과: '11**1**11' (굵은 글씨만 초록색)
- 실제 결과: '1111**1**' (마지막 1이 초록색) ❌

#### 🔍 문제 원인 분석

**1단계: 기본 추적 시스템의 한계**
```python
# 기존 방식: 각 학생별 입력 위치만 추적
self.student_input_positions = {'A': set(), 'B': set(), 'C': set(), 'D': set()}
```
- 문제: 끼워넣기 시 기존 위치들이 올바르게 이동되지 않음
- 결과: 색상이 잘못된 위치에 적용됨

**2단계: 위치 추적 시스템 도입**
```python
# 개선된 방식: 각 위치별로 어떤 학생이 입력했는지 추적
self.position_to_student = {}  # {position: student}
```
- 개선: 전체 텍스트에서 각 문자의 작성자를 정확히 추적
- 한계: 여전히 삽입 위치를 정확히 찾지 못함

**3단계: 삽입 위치 감지의 근본적 문제**
```python
# 기존 문제가 있던 방식: 문자 비교로 삽입 위치 찾기
for idx in range(min(len(prev_text), len(current_text))):
    if prev_text[idx] != current_text[idx]:
        insert_pos = idx  # 첫 번째 다른 위치를 삽입 위치로 판단
        break
```

**왜 이 방식이 실패했는가?**
- '1111' → '11111' (중간에 1 삽입)
- 모든 위치에서 문자가 동일하므로 차이점을 찾을 수 없음
- 결과적으로 삽입 위치를 잘못 판단하여 색상이 엉뚱한 곳에 적용됨

#### ✅ 최종 해결 방법

**핵심 아이디어: 커서 위치 활용**
```python
# 혁신적 해결책: 커서 위치를 활용한 정확한 삽입 위치 계산
cursor_pos = input_text.index(tk.INSERT)
cursor_line, cursor_col = map(int, cursor_pos.split('.'))

# 커서는 삽입 후의 위치를 가리키므로, 실제 삽입 위치는:
insert_pos = cursor_col - added_count
```

**왜 이 방법이 완벽한가?**
1. **정확성**: 커서는 항상 사용자가 실제로 입력한 위치를 정확히 가리킴
2. **범용성**: 어떤 문자든, 몇 개든, 어디에 삽입하든 정확히 작동
3. **단순성**: 복잡한 문자 비교 없이 수학적 계산만으로 해결

#### 🎯 해결 결과

**이제 완벽하게 작동하는 시나리오들:**
- ✅ '1111' 중간에 '1' 삽입 → 정확한 위치만 초록색
- ✅ '++++'  중간에 '+' 삽입 → 정확한 위치만 초록색  
- ✅ '11+11' 형태로 '+' 삽입 → '+' 만 초록색
- ✅ 복잡한 끼워넣기와 편집 → 모든 경우에 정확한 색상 표시

#### 💡 교훈

이 문제는 **"사용자 인터페이스에서 제공하는 정보를 적극 활용하라"**는 중요한 교훈을 보여줍니다. 

복잡한 알고리즘으로 추론하려 하지 말고, GUI 프레임워크가 이미 제공하는 정확한 정보(커서 위치)를 활용하는 것이 때로는 가장 우아한 해결책이 될 수 있습니다.

---

이제 당신도 이 숫자 게임의 전문가입니다! 코드를 직접 수정하며 자신만의 기능을 추가해보세요!